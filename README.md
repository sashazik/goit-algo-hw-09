# Порівняння жадібного алгоритму та динамічного програмування

У цьому завданні було реалізовано два підходи для задачі розміну монет: **Жадібний алгоритм** та **Динамічне програмування**.

**Набір монет:** `[50, 25, 10, 5, 2, 1]`

---

## 1. Жадібний алгоритм (`find_coins_greedy`)



### Принцип роботи
Алгоритм завжди обирає монету найбільшого номіналу, яка не перевищує поточну залишкову суму.

### Ефективність (Часова складність)
* **Складність:** $O(N)$, де $N$ — кількість номіналів монет.
* Оскільки кількість номіналів фіксована (6 штук), можна вважати складність **$O(1)$** (константною) відносно суми. Час виконання майже не змінюється при збільшенні суми.

### Плюси та мінуси
* ✅ **Дуже швидкий.** Миттєво працює навіть для величезних сум.
* ✅ **Ефективний по пам'яті.**
* ⚠️ **Не завжди оптимальний.** Для деяких наборів монет (наприклад, `[1, 3, 4]` для суми `6`) він дасть `4+1+1` (3 монети), хоча оптимально `3+3` (2 монети).
> **Важливо:** Для нашого "канонічного" набору монет він гарантовано дає оптимальний результат.

---

## 2. Динамічне програмування (`find_min_coins`)



### Принцип роботи
Алгоритм будує рішення знизу вгору, обчислюючи мінімальну кількість монет для кожної суми від `1` до заданої `amount`. Він гарантовано знаходить глобальний оптимум.

### Ефективність (Часова складність)
* **Складність:** $O(A \times N)$, де $A$ — сума решти, а $N$ — кількість номіналів.
* Це поліноміальна залежність (псевдополіноміальна). Якщо сума збільшується в 10 разів, час виконання теж збільшується приблизно в 10 разів.

### Плюси та мінуси
* ✅ **Гарантовано оптимальний.** Завжди знаходить мінімальну кількість монет для будь-якого набору номіналів.
* ❌ **Повільний на великих сумах.** Для суми `50,000` йому потрібно виконати сотні тисяч операцій.
* ❌ **Витратний по пам'яті.** Потребує масиву розміром `amount`, що може призвести до переповнення пам'яті при дуже великих числах.

---

## Висновок за результатами тестів

На основі емпіричних даних (`timeit`) можна зробити наступні висновки:

1. **Швидкість:** Жадібний алгоритм працює на порядки швидше. Наприклад, для суми `10,000` жадібний алгоритм витрачає долі мілісекунди, тоді як динамічне програмування може зайняти вже відчутний час.
2. **Масштабованість:** При збільшенні суми час виконання жадібного алгоритму залишається стабільним, тоді як час виконання динамічного алгоритму зростає лінійно.

### Доцільність використання
* **Жадібний алгоритм:** Слід використовувати для стандартних валютних систем, де підхід гарантує оптимум. Він значно ефективніший.
* **Динамічне програмування:** Варто використовувати лише у випадках, коли набір монет нестандартний і жадібний підхід не гарантує мінімальної кількості монет, або коли суми для розміну невеликі.
